---
title: "Publishing Metrics from Spring Boot Application to Amazon CloudWatch"
categories: [craft]
date: 2021-09-02 06:00:00 +1000
modified: 2021-09-02 06:00:00 +1000
author: pratikdas
excerpt: "Amazon CloudWatch is a monitoring and observability service in AWS Cloud. In this article, we will generate different types of application metrics in a Spring Boot web application and send those metrics to Amazon CloudWatch. Amazon CloudWatch will store the metrics data, and help us to derive insights about our application by visualizing the metric data in graphs."
image:
  auto: 0074-stack
---

Metrics provide a quantifiable measure of specific attributes of an application. A collection of different metrics give intelligent insights into the health and performance of an application. 

**Amazon CloudWatch is a monitoring and observability service in the AWS cloud platform**. Among its main capabilities is being a metrics collector and storing the metrics in a time-series database.

In this article, we will generate different types of application metrics in a Spring Boot web application and send those metrics to Amazon CloudWatch. 

**Amazon CloudWatch will store the metrics data, and help us to derive insights about our application by visualizing the metric data in graphs**.

{% include github-project.html url="https://github.com/thombergs/code-examples/tree/master/aws/springcloudwatch" %}

## What is Amazon CloudWatch?

Amazon CloudWatch is a dimensional time-series service in the AWS cloud platform with capabilities of :
1. Collecting and monitoring logs.
2. Storing metrics from AWS resources, and applications running in AWS or outside AWS.
3. Providing system-wide visualization with graphs and statistics.
4. Creating alarms that watch a single CloudWatch metric and perform some actions based on the value of the metric.

We will use only the metrics storing and visualization capability of CloudWatch here for the metrics generated by a Spring Boot application. 

Hence it will be worthwhile to introduce a few concepts important for creating the metrics in our application:

**Metric**: Metric is a fundamental concept in CloudWatch. It is associated with one or more measures of any application attribute at any point in time and is represented by a data point with a time stamp.

**NameSpace**: A namespace is a container for CloudWatch metrics. We specify a namespace for each data point published to CloudWatch. 

**Dimension**: A dimension is a name/value pair that is part of the identity of a metric. We can assign up to 10 dimensions to a metric.

Metrics are uniquely defined by a name, a namespace, and zero or more dimensions. Each data point in a metric has a time stamp, and optionally a unit of measure. 

When we choose CloudWatch to monitor our application, then the data about certain attributes of the application is sent to CloudWatch as a data point for a metric at regular intervals.

Please refer to the [official documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html) for a more elaborate explanation of Amazon CloudWatch concepts and capabilities.

In the subsequent sections, we will create a Spring Boot application, and generate some metrics in the application, and ship them to Amazon CloudWatch. After the metrics are published in CloudWatch, we will visualize them using CloudWatch graphs.

## Creating the Web Application for Capturing Metrics

With this basic understanding of Amazon CloudWatch, let us now create a web application with the Spring Boot framework for creating our metrics.

Let us first create a Spring Boot project with the help of the [Spring boot Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.5.3.RELEASE&packaging=jar&jvmVersion=11&groupId=io.pratik&artifactId=metricscapture&name=metricscapture&description=Demo%20project%20for%20capturing%20cloudwatch%20metrics%20in%20Spring%20Boot&packageName=io.pratik.metricscapture&dependencies=web,lombok), and then open the project in our favorite IDE. We have added dependencies on the `web` and `lombok` modules in our Maven `pom.xml`. 

Our web application will have a REST API for fetching products in an online shopping application. 
We have created our API in the following class using the annotations from the `Spring Web` dependency:

```java
@RestController
@Slf4j
public class ProductController {

  @GetMapping("/products")
  @ResponseBody
  public List<Product> fetchProducts() {
    
    List<Product> products = fetchProductsFromStore();
        
    return products;
  }
  
  /**
   * Dummy method to fetch products from any datastore
   * 
   */
  private List<Product> fetchProductsFromStore(){
    List<Product> products = new ArrayList<Product>();
    products.add(Product.builder().name("Television").build());
    products.add(Product.builder().name("Book").build());
    return products;
  }
 
}

```
The fetch products API is created with the `fetchProducts` method in this `ProductController` class will accept HTTP GET requests at `http://localhost:8080/products` and respond with a JSON representation of a list of products.

In the next sections, we will enrich this application to capture three metrics each with a specific purpose:
1. Measure the number of HTTP requests for the fetch products API.
2. Track the fluctuation in the price of a product.
3. Total execution time of the fetch products API.

## Integrating the Application with CloudWatch
The simplest way for an application to send metrics to CloudWatch is by using the [AWS Java SDK](https://aws.amazon.com/sdk-for-java/). The below code shows a service class for sending metrics to CloudWatch using AWS Java SDK:


```java

@Configuration
public class AppConfig {
  @Bean
  public CloudWatchAsyncClient cloudWatchAsyncClient() {
    return CloudWatchAsyncClient
           .builder()
           .region(Region.US_EAST_1)
           .credentialsProvider(
             ProfileCredentialsProvider
             .create("pratikpoc"))
           .build();
  }
}

@Service
public class MetricPublisher {
  
  private CloudWatchAsyncClient cloudWatchAsyncClient;
  
  @Autowired
  public MetricPublisher(CloudWatchAsyncClient cloudWatchAsyncClient) {
    super();
    this.cloudWatchAsyncClient = cloudWatchAsyncClient;
  }

  public void putMetricData(final String nameSpace, 
            final String metricName, 
            final Double dataPoint,
            final List<MetricTag> metricTags) {

    try {
      
      List<Dimension> dimensions = metricTags
          .stream()
          .map((metricTag)->{
                 return Dimension
                   .builder()
                   .name(metricTag.getName())
                   .value(metricTag.getValue())
                   .build();
      }).collect(Collectors.toList());      
      
      // Set an Instant object
      String time = ZonedDateTime
                 .now(ZoneOffset.UTC)
                 .format(DateTimeFormatter.ISO_INSTANT);
      Instant instant = Instant.parse(time);
      
      MetricDatum datum = MetricDatum
               .builder()
               .metricName(metricName)
               .unit(StandardUnit.NONE)
               .value(dataPoint)
               .timestamp(instant)
               .dimensions(dimensions)
               .build();
      
      PutMetricDataRequest request = 
                 PutMetricDataRequest
                 .builder()
                 .namespace(nameSpace)
                 .metricData(datum)
                 .build();
      
      cloudWatchAsyncClient.putMetricData(request);
    
    } catch (CloudWatchException e) {
       System.err.println(e.awsErrorDetails().errorMessage());
    }
  }
}

public class MetricTag {
  private String name;
  private String value;
  public MetricTag(String name, String value) {
    super();
    this.name = name;
    this.value = value;
  }
  // Getters
  ...
  ...
}

```
In this code snippet, we are establishing the connection to Amazon CloudWatch by setting up the `CloudWatchAsyncClient` with our AWS profile credentials. The request for sending the metric is created in the `putMetricData` method. 

The metric is created by specifying the name of the metric, and the namespace under which the metrics will be created along with one or more tags associated with the metric called dimensions.

## Using Micrometer to Decouple the Application from CloudWatch

We will make use of the Micrometer library, instead of the AWS Java SDK, to create our metrics and send them to Amazon CloudWatch. 

Micrometer acts as a facade to different monitoring systems by providing a tool agnostic interface for collecting metrics from our application and publishing the metrics to our target metrics collector. 

![CloudWatch Metrics](/assets/img/posts/aws-spring-cloudwatch/monitoringfacade.png)

This enables us to support multiple metrics collectors and switch between them with minimal configuration changes.

## Micrometer MeterRegistry and Meters 
`MeterRegistry` and `Meter` are the two central concepts in Micrometer. A `Meter` is the interface for collecting metrics about an application. `Meters` in Micrometer are created from and held in a `MeterRegistry`. A sample code for instantiating a `MeterRegistry` will look like this:

```java
MeterRegistry registry = new SimpleMeterRegistry();
```
`SimpleMeterRegistry` is a default implementation of `MeterRegistry` bundled with Micrometer. It holds the latest value of each meter in memory and does not export the data to any metrics collector. The diagram here shows the hierarchy and relationships of important classes and interfaces of the Micrometer.

![CloudWatch Metrics](/assets/img/posts/aws-spring-cloudwatch/micrometer-classes.png)


We can see different types of Meters and MeterRegistries in this diagram.

**MeterRegistry represents the monitoring system where we want to push the metrics for storage and visualization**.

Each [supported monitoring system](https://micrometer.io/docs/concepts#_supported_monitoring_systems) has an implementation of `MeterRegistry`. For example, for sending metrics to Amazon CloudWatch we will use `CloudWatchMeterRegistry`. 

Each meter type gets converted into one or more metrics in a format compatible with the target monitoring system like Amazon CloudWatch in our application.

Micrometer comes with the following set of Meters:
Timer, Counter, Gauge, DistributionSummary, LongTaskTimer, FunctionCounter, FunctionTimer, and TimeGauge. Among these, we will use Timer, Counter, Gauge in our application. 

Let us understand the kind of measures they can be typically used for:

1. **Counter**: Counter is used to measure numerical values which only increase. They can be used to count requests served, tasks completed, errors that occurred, etc. 

2. **Gauge**: A Gauge represents a numerical value that can both increase and decrease. Gauge is used to measure values like current CPU usage, cache size, the number of messages in a queue, etc.

3. **Timer**: Timer is used for measuring short-duration latencies, and the frequency of such events. All implementations of `Timer` report at least the total time and count of events as separate time series.

## Spring Boot Integration with Micrometer
Coming back to our application, we will first integrate Micrometer with our Spring Boot application to produce these metrics. We do this by first adding a dependency on Micrometer core library named `micrometer-core` :

```xml
    <dependency>
      <groupId>io.micrometer</groupId>
      <artifactId>micrometer-core</artifactId>
    </dependency>
```
This library provides classes for creating the meters and pushing the metrics to the target monitoring system.

We next add dependency for the target monitoring system. We are using Amazon CloudWatch so we will add a dependency to `micrometer-registry-cloudwatch2` module in our project:

```xml
    <dependency> 
        <groupId>io.micrometer</groupId> 
        <artifactId>micrometer-registry-cloudwatch2</artifactId> 
    </dependency> 
```
This module uses AWS Java SDK version 2 to integrate with Amazon CloudWatch. An earlier version of the module named `micrometer-registry-cloudwatch` uses the AWS Java SDK version 1. Version 2 is the recommended version to use.

This library does the transformation from Micrometer meters to the format of the target monitoring system. Here the `micrometer-registry-cloudwatch2` library converts Micrometer meters to CloudWatch metrics. 


## Creating the MeterRegistry

We will now create the `MeterRegistry` implementation for Amazon CloudWatch to create our Meters and push the metrics to Amazon CloudWatch. We do this in a Spring configuration class as shown here:


```java
@Configuration
public class AppConfig {
  

  @Bean
  public CloudWatchAsyncClient cloudWatchAsyncClient() {
    return CloudWatchAsyncClient
        .builder()
        .region(Region.US_EAST_1)
        .credentialsProvider(
          ProfileCredentialsProvider
          .create("pratikpoc"))
        .build();
  }
  
  @Bean
  public MeterRegistry getMeterRegistry() {
    CloudWatchConfig cloudWatchConfig = setupCloudWatchConfig();
    
    CloudWatchMeterRegistry cloudWatchMeterRegistry = 
        new CloudWatchMeterRegistry(cloudWatchConfig, 
                                    Clock.SYSTEM,
                                    cloudWatchAsyncClient()
                                    );
        
    return cloudWatchMeterRegistry;
  }

  private CloudWatchConfig setupCloudWatchConfig() {
    CloudWatchConfig cloudWatchConfig = new CloudWatchConfig() {
      
      private Map<String, String> configuration
            = Map.of("cloudwatch.namespace", "productsApp",
                     "cloudwatch.step", Duration.ofMinutes(1).toString());
      
      @Override
      public String get(String key) {
        return configuration.get(key);
      }
    };
    return cloudWatchConfig;
  }

}

```
In this code snippet, we have defined `CloudWatchMeterRegistry` as a Spring bean. For creating our registry we are first creating a new `CloudWatchConfig` which is initialized with two configuration properties: `cloudwatch.namespace` and `cloudwatch.step` so that it publishes all metrics to the `productsApp` namespace every minute. 

After configuring the `MeterRegistry`, we will look at how we register and update our meters in the next sections.

We will register three meters:
1. Counter to measure the count of views of the product list page.
2. Gauge to track the price of a product
3. Timer to record time of execution of `fetchProducts` method.

## Registering and Incrementing the Counter

We want to count the number of views of the products list page in our application. We do this by updating the meter of type counter since this measure always goes up. In our application we register the counter for page views in the constructor and increment the counter when the API is invoked as shown in the code snippet below: 

```java
@RestController
@Slf4j
public class ProductController {
  private Counter pageViewsCounter;
  
  private MeterRegistry meterRegistry;
 
  @Autowired
  ProductController(MeterRegistry meterRegistry,
                    PricingEngine pricingEngine){
    
     this.meterRegistry = meterRegistry;
      
     pageViewsCounter = meterRegistry
         .counter("PAGE_VIEWS.ProductList");
  }
  
  @GetMapping("/products")
  @ResponseBody
  public List<Product> fetchProducts() {
    long startTime = System.currentTimeMillis();
    
    List<Product> products = fetchProductsFromStore();
    
    // increment page views counter
    pageViewsCounter.increment();
        
    return products;
  }
  
  private List<Product> fetchProductsFromStore(){
    List<Product> products = new ArrayList<Product>();
    products.add(Product.builder().name("Television").build());
    products.add(Product.builder().name("Book").build());
    return products;
  }
}
```


Here we are registering the meter of type counter by calling the `counter` method on our `CloudWatchRegistry` object created in the previous section. This method is accepting the name of the meter as a parameter.

## Registering and Recording the Timer
Now we want to record the time taken to execute the API for fetching products. This is a measure of short duration latency so we will make use of a meter of type `Timer`.

We will register the `Timer` by calling the `Timer` static method on the registry object in the constructor of our controller class as shown here: 

```java
@RestController
@Slf4j
public class ProductController {
  private Timer productTimer;
  private MeterRegistry meterRegistry;
 
  @Autowired
  ProductController(MeterRegistry meterRegistry, 
                    PricingEngine pricingEngine){
    
     this.meterRegistry = meterRegistry;
     productTimer = meterRegistry
         .timer("execution.time.fetchProducts"); 
  }
  
  
  @GetMapping("/products")
  @ResponseBody
  public List<Product> fetchProducts() {
    long startTime = System.currentTimeMillis();
    
    List<Product> products = fetchProductsFromStore();
 
    // record time to execute the method
    productTimer.record(Duration
      .ofMillis(System.currentTimeMillis() 
                - startTime));
        
    return products;
  }
  
  private List<Product> fetchProductsFromStore(){
    List<Product> products = new ArrayList<Product>();
    // Fetch products from database or external API
    return products;
  }
}

```
We have set the name of the `Timer` as `execution.time.fetchProducts` when registering in the constructor. In the `fetchProducts` method body we record the execution time by calling the `record` method. 

## Registering and Updating the Gauge
We will next register a meter of type `Gauge` to track the price of a product. For our example, we are using a fictitious pricing engine to compute the price at regular intervals. We have used a simple Java method for the pricing engine but in real life, it could be a sophisticated rules-based component. The price can go up and down so `Gauge` is an appropriate meter to track this measure.

We are constructing the Gauge using the fluent builder interface of the Gauge as shown below:

```java
@RestController
@Slf4j
public class ProductController {
  private Gauge priceGauge;
  
  private MeterRegistry meterRegistry;
  
  private PricingEngine pricingEngine;

  @Autowired
  ProductController(MeterRegistry meterRegistry, 
                    PricingEngine pricingEngine){
    
     this.meterRegistry = meterRegistry;
     this.pricingEngine = pricingEngine;
         
     priceGauge = Gauge
            .builder("product.price", pricingEngine , 
               (pe)->{
                   return pe != null? 
                      pe.getProductPrice() : null;}
                )
            .description("Product price")
            .baseUnit("ms")
            .register(meterRegistry);
  }
  
 ...
 ...
 
}

@Service
public class PricingEngine {
  
  private Double price;
  
  public Double getProductPrice() {
    return price; 
  }
  
  @Scheduled(fixedRate = 70000)
  public void computePrice() {
    
    Random random = new Random();
    price = random.nextDouble() * 100;

  }

}
```
As we can see in this code snippet, the price is computed every `70000` milliseconds specified by the  `Scheduled` annotation over the `computePrice` method.

We have already set up the gauge during registration to track the price automatically by specifying the function `getProductPrice`.


## Visualizing the Metrics in CloudWatch

Let us open the [AWS CloudWatch console](https://console.aws.amazon.com/cloudwatch/) to see the metrics in CloudWatch generated from the Micrometer meters in the previous section. Our metrics will be grouped under the namespace `productApp` which we had configured in our application when generating the metrics. 

The namespace we have used to create our metrics appears under the custom namespaces section as can be seen in this screenshot:

![CloudWatch Metrics namespaces](/assets/img/posts/aws-spring-cloudwatch/cw-namespaces.png)

Here we can see our namespace `productApp` containing `6 metrics`. Let us get inside the namespace to see the list of metrics as shown below:

![CloudWatch Metrics](/assets/img/posts/aws-spring-cloudwatch/cloudwatch-metrics.png)

These are the metrics for each of the meters (Counter, Timer, and Gauge) of Micrometer which we had registered and updated in the application in the earlier sections:

| Micrometer Meter | Meter Type | CloudWatch Metric |
| :--- | :--- | :---: |
| product.price | Gauge | product.price.value |
| PAGE_VIEWS.ProductList | Counter | PAGE_VIEWS.ProductList.count |
| execution.time.fetchProducts | Timer | execution.time.fetchProducts.avg <br />  execution.time.fetchProducts.count <br /> execution.time.fetchProducts.max <br /> execution.time.fetchProducts.sum |

The metric values rendered in the CloudWatch graph is shown below:

The Gauge for tracking the price of a product is mapped to 1 metric named `product.price.value`.

![CloudWatch Gauge](/assets/img/posts/aws-spring-cloudwatch/cw-gauge.png)

The Counter for measuring the number of page views of `productList` page is mapped to 1 metric named `PAGE_VIEWS.ProductList.count`. We measured this in our application by incrementing the meter for page views on every invocation of the `fetchProducts` API.

![CloudWatch Counter](/assets/img/posts/aws-spring-cloudwatch/cw-counter.png)

The Timer meter for measuring the execution time of the `fetchProducts` API is mapped to 3 metrics named `execution.time.fetchProducts.count`, `execution.time.fetchProducts.max`, and `execution.time.fetchProducts.sum` representing the API's total execution time, and maximum and sum of the execution times during an interval.
![CloudWatch Timer](/assets/img/posts/aws-spring-cloudwatch/cw-timer.png)


## Conclusion

Here is a list of important points from the article for quick reference:

1. Micrometer is used as a facade to publish metrics from our application to different monitoring systems. 
2. Micrometer works as a flexible layer of abstraction between our code and the monitoring systems so that we can easily swap or combine them.
3. MeterRegistry and Meter are two important concepts in Micrometer.
4. Counter, Timer, and Gauge are the three commonly used types of Meter.
5. Each monitoring system supported by Micrometer has an implementation of MeterRegistry.
6. The meter types are converted to one or more time-series metrics at the time of publishing to the target monitoring system.
7. Amazon CloudWatch is a monitoring and observability service in AWS Cloud.
8. Namespace, metric, and dimension are three important concepts in Amazon CloudWatch.
9. A metric in CloudWatch is uniquely identified by its name, namespace, and dimension.

You can refer to all the source code used in the article on [Github](https://github.com/thombergs/code-examples/tree/master/aws/springcloudwatch).

