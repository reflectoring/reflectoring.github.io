---
title: "How to Internationalize a Spring Boot Application"
categories: [spring-boot]
date: 2021-09-30 06:00:00 +1000
modified: 2021-09-30 06:00:00 +1000
author: pratikdas
excerpt: "Internationalization is the process of making an application adaptable to multiple languages and regions without major changes in the source code. In this article, we will illustrate how to internationalize a Spring Boot application."
image:
  auto: 0074-stack
---

Internationalization is the process of making an application adaptable to multiple languages and regions without major changes in the source code.

In this article, we will illustrate how to internationalize a Spring Boot application.

{% include github-project.html url="https://github.com/thombergs/code-examples/tree/master/spring-boot/spring-boot-i18n" %}

## Internationalization (i18n) vs Localization (l10n)

Internationalization is a mechanism to create multilingual software that can be adapted to different languages and regions. During internationalization of an application, we make the code language neutral so that we do not have to create a new application when adding support for more languages in the future. 

Internationalization is also abbreviated as i18n because there is a total of 18 characters between the first letter 'i' and the last letter 'n'.

The following figure is an example of the Amazon the e-commerce site supporting internationalization:

![i18n example](/assets/img/posts/spring-boot-i18n/i18nexample.png)

Here we can see the same content in the Amazon website rendered in French and German languages.

Internationalization is most often a one-time process undertaken during the initial stages of design and development. 

A related term: Localization is the process of adapting the internationalized application to a specific language and region by adding region-specific text and components. 

For example, when we add support for the French language, we are localizing the application for French. Without localization, the default English text will be shown to the user who is viewing the website from a non-English region.

Localization is typically conducted by translators on the user-facing components of the software. It also refers to localizing the time and date differences, currency, culturally appropriate images, symbols, spelling, and other locale-specific components (including the RTL languages like Arabic).

Unlike internationalization, localization is the process of adding language files and region-specific content every time we add support for a new language.

Localization is also abbreviated as l10n because there is a total of 10 characters between the first letter 'l' and the last letter 'n'. 


## Introducing the Locale

A locale in the context of internationalization represents a user's language, geographical region, and any specific variant like dialect.

An object of the Java Locale class consists of at least a language code and a country or region code. used for identifying objects, not a container for the objects themselves. 

The language codes are lower-case, two-letter codes defined by ISO-639. 

The country codes are upper-case, two-letter codes defined by ISO-3166. 

The Java Locale class also contains convenient constants for commonly used locales. For example, the `Locale.US` creates a Locale object for the United States.

## Creating the Spring Boot Application for Internationalization

To work with some examples of internationalization, let us first create a Spring Boot project with the help of the [Spring boot Initializr](https://start.spring.io/#!type=maven-project&language=java&platformVersion=2.5.4&packaging=jar&jvmVersion=11&groupId=io.pratik.i18n&artifactId=productapp&name=productapp&description=Demo%20project%20for%20Spring%20Boot%20Internationalization&packageName=io.pratik.i18n.productapp), and then open the project in our favorite IDE. We have not added any dependencies to Maven `pom.xml` since the scheduler is part of the core module of the Spring framework.

We will create a web application in this project using Spring MVC framework which will render an HTML page in different languages depending on the user's language selection.

## Steps for Internationalization

Internationalization of applications broadly follows the below steps:

1. Resolving the user's preferred locale from the incoming request from the user either in the form of a request parameter, cookies, or a request header.
2. Intercepting the change of locale in the incoming request and storing it in the user's session or cookies.
3. Defining locale-specific resources, for example, language files for supported languages.


Let us look at these steps in detail:

## Resolving the Locale with LocaleResolver
We use the `LocaleResolver` interface for resolving the locale of a user from the incoming request. 

Spring provides the following implementations of the `LocaleResolver` interface that determine the current locale based on the session, cookies, the `Accept-Language` header, or sets the locale to a fixed value:

- **FixedLocaleResolver**: Mostly used for debugging purposes. It resolves the locale to a fixed language mentioned in the `application. properties`.
- **AcceptHeaderLocaleResolver**: Resolves the locale using an `accept-language` HTTP header retrieved from an HTTP request. 
- **SessionLocaleResolver**: Resolves the locale and stores it in the HttpSession of the user. 

- **CookieLocaleResolver**: Resolves the locale and stores it in a cookie stored on the user’s machine

Let us update our application by adding a `LocaleResolver` bean to our Spring configuration class:

```java
@Configuration
public class MessageConfig implements WebMvcConfigurer{

  
  @Bean
  public LocaleResolver localeResolver() {
      SessionLocaleResolver slr = new SessionLocaleResolver();
      slr.setDefaultLocale(Locale.US);
      slr.setLocaleAttributeName("session.current.locale");
      slr.setTimeZoneAttributeName("session.current.timezone");
      return slr;
  }

}

```
Here we have configured a `SessionLocaleResolver` that will store the locale in a session. The default locale is set to `US`. We have also set the names of the session attributes that will store the current locale and time zone.

## Intercepting the Locale Change with LocaleInterceptor
Next, our application will need to detect the change in the user's locale and switch to the new locale. This function is performed with a `HandlerInterceptor`.

The `HandlerInterceptor` is a component of the [Spring MVC framework](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html). The framework is designed around a `DispatcherServlet` dispatching requests to configurable handler mappings. An example of a handler mapping which we are also using in our example is an URL mapped to a method.

Interceptors perform actions before and after the request is handled. 

Spring provides `LocaleChangeInterceptor` for handling the change in locale:

```java
@Configuration
public class MessageConfig implements WebMvcConfigurer{
 ...
 ...
  
  @Bean
  public LocaleChangeInterceptor localeChangeInterceptor() {
      LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor();
      localeChangeInterceptor.setParamName("language");
      return localeChangeInterceptor;
  }
  
  @Override
  public void addInterceptors(InterceptorRegistry registry) {
      registry.addInterceptor(localeChangeInterceptor());
  }

}
```
Here we have added the `LocaleChangeInterceptor` bean that will switch to a new locale based on the value of the `language` parameter appended to a request and also added it to the interceptor to the `InterceptorRegistry`.

The `MessageConfig` class also implements the `WebMvcConfigurer` interface which defines callback methods to customize the default Java-based configuration for Spring MVC.

## Configuring the Resource Bundles
Now we will create the resource bundles for defining various texts for the corresponding locales that we want to support in our application.

A resource bundle in Java is a set of properties files with the same base name and a language-specific suffix. For example, if we create `messages_en.properties` and `messages_de.properties`, they together form a resource bundle with a base name of `messages`. 

The resource bundle should also have a default properties file with the same name as its base name which is used as the fallback if a specific locale is not supported. 

The following diagram shows the properties files of a resource bundle with a base name of `language/messages`:

![resource-files](/assets/img/posts/spring-boot-i18n/i18nexample.png)

Here we can see resource bundles for three languages: English, French, and German with English being the default. 

Each resource bundle contains the same items, but the items are translated for the locale represented by that resource bundle. 

For example, both `messages. properties` and `messages_de.properties` have a text with a key: `label.title`  that is used as the title of a page. In `messages.properties` the text contains `List of Products` and in `messages_de.properties` it contains the German Translation `Produktliste`.

Spring provides the `ResourceBundleMessageSource` class which is an implementation of the [MessageSource](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/MessageSource.html) interface and accesses the Java resource bundles using specified base names.

When configuring the `MessageSource` we define the path for storing the message files for the supported languages as shown below:

```java
@Configuration
public class MessageConfig implements WebMvcConfigurer{
  
  @Bean("messageSource")
  public MessageSource messageSource() {
      ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
      messageSource.setBasenames("language/messages");
      messageSource.setDefaultEncoding("UTF-8");
      return messageSource;
  }
  ...
  ...

}

```

Here we have defined the base name of our resource bundle as `language/messages`.

Alternatively we can configure the `MessageSource` in `application.properties`:

```.properties
spring.messages.basename=language/messages
```

## Internationalizing the View

Now it is time to internationalize the view which will render in the language of the user's chosen locale. 

One of the common techniques is of internationalizing is by using placeholders for text in our user interface code instead of hardcoding the text in a particular language. 

During runtime, the placeholder will be replaced by the text corresponding to the language of the user viewing the website.
The view in our application will be defined in HTML where we will use Thymeleaf tags for the labels instead of hard coding a fixed text. 

[Thymeleaf](https://www.thymeleaf.org) is a Java template engine for processing and creating HTML, XML, JavaScript, CSS, and plain text. 

Spring Boot provides auto-configuration for Thymeleaf by adding the thymeleaf starter dependency:

```xml
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>
```
Adding the `spring-boot-starter-thymeleaf` dependency configures the necessary defaults including the path for HTML files for the view. By default, the HTML files are placed in the `resources/templates` location. We have created an HTML file `index.html` in the same path.

Here is the Thymeleaf HTML code to display the value associated with the key `label.title` in our resource bundle configured to a `MessageSource` bean in the Spring configuration class:

```html
 <html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title data-th-text="#{label.title}"></title>
  </head>
  <body>
    <h2 data-th-text="#{label.title}"></h2>
    ...
    ...
  </body>
 </html>   
```

In the HTML code snippet, we are using thymeleaf tags for the text for the HTML page title and header. The `data-th-text=”#{key from properties file}”` tag attribute is used to display values from property files configured as a `MessageSource` bean in the Spring configuration class in the previous section.

The values of the text for the key `label.title` for different locales are shown below:

Label in English defined in `messages.properties`:
```.properties
label.title = List of Products
```
Label in French defined in `messages_fr.properties`:
```.properties
label.title = Liste des produits
```

Label in German defined in `messages_de.properties`:
```.properties
label.title = Produktliste
```

When we run the application, we can see the text for the user's locale:


We can similarly define the remaining HTML labels in the resource bundles:

The text for the English language are defined in the default message file `messages.properties`:

```.properties
label.product.name = Product Name
label.product.price = Price
label.product.lastUpdated = Last Updated
label.title = List of Products
label.chooseLang = Choose language
...
...
```
SImilarly the text for the French language are defined in `messages_fr.properties` :

```.properties
label.product.name = Nom du produit
label.product.price = Prix
label.product.lastUpdated = Dernière mise à jour

label.title = Liste des produits
label.chooseLang = Choisissez la langue

...
...
```
As we can see from these resource bundles for the French, and English (used as default),
the keys for the values that will be localized are the same in every file.

If a key does not exist in a requested locale, then the application will fall back to the default locale value. For example, if we do not define a key in the french language, then the English language text will be displayed.

## Adding the Spring MVC Components

At last, we will add the controller class for Spring MVC by annotating it with the `@Controller` annotation. This will mark the class as a Spring Controller which will contain the endpoints:

```java
@Controller
public class ProductsController {
  
  @GetMapping("/index")
  public ModelAndView index() {
    
    ModelAndView modelAndView = new ModelAndView();    
    modelAndView.setViewName("index");   
    
    List<Product> products = fetchProducts();
    modelAndView.addObject("products", products); 
            
    return modelAndView;    
  }

  /**
   * Dummy method to simulate fetching products from a data source.
   *
   * @return
   */
  private List<Product> fetchProducts() {
    Locale locale = LocaleContextHolder.getLocale();
        
    List<Product> products = new ArrayList<Product>();
    
    Product product = new Product();
    product.setName("television");
    product.setPrice(localizePrice(locale, 15678.43));
    product.setLastUpdated(localizeDate(locale, LocalDate.of(2021, Month.SEPTEMBER, 22)));
    products.add(product);
    
    product = new Product();
    product.setName("washingmachine");
    
    product.setPrice(localizePrice(locale, 152637.76));
    product.setLastUpdated(localizeDate(locale, LocalDate.of(2021, Month.SEPTEMBER, 20)));
    products.add(product);
    return products;
  }
  
  private String localizeDate(final Locale locale, final LocalDate date ) {
    String localizedDate = DateTimeFormatter.ISO_LOCAL_DATE.format(date);
    return localizedDate; 
  }
  
  
  private String localizePrice(final Locale locale, final Double price ) {
    NumberFormat numberFormat=NumberFormat.getInstance(locale);
    String localizedPrice = numberFormat.format(price);
    return localizedPrice;  
  }
}

```
Here we have added `ProductsController` as the controller class. We have added the `index` method where we are populating the model for a collection of products. The view name is set to `index` which maps to the view `index.html`.

```html
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title data-th-text="#{label.title}"></title>
  </head>
  <body>
...
...
    <table border="1">
 ...
 ...
      <tr th:each="product: ${products}">
        <td data-th-text="#{__${product.name}__}"></td>
        <td data-th-text="${product.price}" />
        <td data-th-text="${product.lastUpdated}" />
      </tr>
    </table>
  </body>
</html>

```

In this `index.html`, we have used the `data-th-text` to read the values from our resource bundles based on the user's locale.

## Conclusion

Here is a list of major points for quick reference:

1. Internationalization is a mechanism to create multilingual software that can be adapted to different languages and regions.
2. A related term: Localization is the process of adapting the internationalized application to a specific language and region by adding region-specific text and components. 
3. A locale in the context of internationalization represents a user's language, geographical region, and any specific variant like dialect.
4. Language specific text is defined in resource bundle which is a set of properties files with the same base name and a language-specific suffix.
5. Spring Boot uses the `ResourceBundleMessageSource` to access the Java resource bundles using specified base names. 
6. The user's locale is resolved from the incoming request through `LocaleResolver` class and change in locale is intercepted by the `LocaleChangeInterceptor` classe. 

You can refer to all the source code used in the article on [Github](https://github.com/thombergs/code-examples/tree/master/spring-boot/spring-boot-i18n).

