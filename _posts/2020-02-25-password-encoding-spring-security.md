---
title: Password Encoding with Spring Security
categories: [spring-boot]
date: 2020-02-25 06:00:00 +1100
modified: 2020-02-25 06:00:00 +1100
author: artur
excerpt: "When we store user passwords, we have to do it securely. Let's have a look how to handle passwords with Spring Security in a Spring Boot application."
image:
  auto: 0063-password
---

Systems with user management require authentication. If we use password-based authentication,
we have to handle users' passwords in our system. This article shows how to encode and store passwords securely
with Spring Security.

{% include github-project.html url="https://github.com/thombergs/code-examples/tree/master/spring-boot/password-encoding/" %}

# Storing Passwords on the Server
If we want to authenticate the user on the server side, we have to follow these steps:
1. Get the password from the user who wants to authenticate.
2. Find the user in the storage, usually a database.
3. Compare the password the user provided with the user's password from the database. 

## Saving Passwords as Plain Text
We have to deal with the fact that we have to save users' passwords in our system for comparison during authentication.

**Obviously, it is a bad idea to save passwords as plain text in the database.** 

We should assume
that an attacker can steal the database with passwords or get access to the passwords by other methods like SQL injection.

In this case, the attacker could use the password right away to access the application. So we need to save the passwords
in a form that the attacker can't use it for authentication.
 
## Hashing

 __Hashing solves the problem of *immediate*
access to the system with exposed passwords.__

Hashing is a one-way function that converts the input to a line of symbols. Normally the length of this line is fixed.

If the data is hashed, it's very hard to convert the hash back to the original input and it's also very hard to find the
input to get the desired output. 

We have to hash the password in two cases:
 
 * When the user registers in the application we hash the password and save it to the database. 
 * When the user wants to authenticate, we hash the provided password and compare it with the password hash from the database.

Now, when attackers get the hash of a password, they are not able to use it for accessing the system. Any attempt to find the plain text from the hash value requires a huge effort from the attacker. A brute force attack can be very expensive
if the hash is long enough. 

**Using rainbow tables, attackers still can have success, however**. A rainbow table is a table with
precomputed hashes for many passwords. There is a lot of rainbow tables available on the internet and some of them contain millions of
passwords.

## Salt the Password

To prevent an attack with rainbow tables we can use salted passwords. A salt is a sequence of randomly generated bytes,
that are hashed along with the password. The salt is stored in the storage and it doesn't need to be protected.

Whenever the user tries to authenticate, the user's password is hashed with the saved salt and the result should match
the stored password. 

The probability that the combination of the password and the salt is precomputed
in a rainbow table is very small. **If the salt is long and random enough, it is impossible to find the hash in a rainbow table.**

Since the salt is not a secret, attackers are still able to start a brute force attack, though.

A salt can make the attack difficult to the attacker, but hardware is getting more efficient. We must assume fast-evolving hardware with which the attacker can calculate billions of hashes per second.

Thus, __hashing and salting are necessary - but not enough.__

## Password Hashing Functions
Hash functions were not created to hash only passwords. The inventor of hash functions did a very good job
and made the hash function very fast. 

If we can hash passwords very fast, though, then an attacker can run the brute force attack
very fast too. 

**The solution is to make password hashing slow**. 

But how slow can it be? It should not be so slow as to be unacceptable for the user, but slow enough to make a brute force attack take infinite time.

We don't need to develop the slow hashing on our own. There are several algorithms, that are developed especially 
for password hashing. For example:
* bcrypt,
* scrypt,
* PBKDF2,
* argon2,
* and others.

They use a complicated cryptographic algorithm and allocate resources like CPU or memory deliberately.


## Work Factor
Work factor is a configuration of the encoding algorithms that can be increased with growing hardware power.
Every password encoding has its own work factor. Work factor influences the speed of the password encoding.
For instance, `bcrypt` has the parameter `strength`. This is the two to the power of `strength` and means the number of iteration
using by the algorithm. The bigger the the number is, the slower the encoding works. 

# Password Encoding with Spring Security
Now let's see how Spring Security supports these algorithms and how we can handle passwords with them.

## Password Encoders
First, let's have a look at the password encoders of Spring Security.
All password encoders implement the interface `PasswordEncoder`.

This interface defines methods `encode()` to convert the plain
password to the encoded form and the method `matches()` to compare the plain password with the encoded password.

Every encoder has a default constructor
that creates an instance with the default work factor. We can use other constructors for tuning the work factor.


### `BCryptPasswordEncoder`
```java
 int strength = 10; // work factor of bcrypt
 BCryptPasswordEncoder bCryptPasswordEncoder =
  new BCryptPasswordEncoder(strength, new SecureRandom());
 String encodedPassword = bCryptPasswordEncoder.encode(plainPassword);
```

`BCryptPasswordEncoder` has the parameter `strength`. The default value in Spring Security is `10`.
It is recommended to use a `SecureRandom` as salt generator, because it provides a cryptographically strong random number.

The output looks like this:
```
$2a$10$EzbrJCN8wj8M8B5aQiRmiuWqVvnxna73Ccvm38aoneiJb88kkwlH2
```

Note that in contrast to simple hash algorithms like SHA-256 or MD5, the output of `bcrypt` contains meta information
about the version of the algorithm, work factor, and salt. We don't need to save this information separately.

### `Pbkdf2PasswordEncoder`
```java
String pepper = "pepper"; // secret key used by password encoding
int iterations = 200000;  // number of hash iteration
int hashWidth = 256;  // hash width in bits

Pbkdf2PasswordEncoder pbkdf2PasswordEncoder =
  new Pbkdf2PasswordEncoder(pepper, iterations, hashWidth);
pbkdf2PasswordEncoder.setEncodeHashAsBase64(true);
String encodedPassword = pbkdf2PasswordEncoder.encode(plainPassword);
```  

The PBKDF2 algorithm was not designed for password encoding but the key derivation from a password.
The key derivation is usually needed when we want want to encrypt some data with a password, but the
password is not strong enough to be used as an encryption key.
This encoder runs the hash algorithm over the plain password many times. It generates a salt, too. We
can define how long the output can be and additionally we can use a secret called `pepper` to
make the password encoding more secure.

The output looks like this:

```
lLDINGz0YLUUFQuuj5ChAsq0GNM9yHeUAJiL2Be7WUh43Xo3gmXNaw==
```

The salt is saved within, but we have to save the iteration number and hash width separately. The `pepper`
should be kept as a secret.
The default value of the iteration number is 185000 and the hash width is 256.

### `SCryptPasswordEncoder`
```java
int cpuCost = (int) Math.pow(2, 14); // factor to increase CPU costs
int memoryCost = 8;  // factor to increases memory usage, not the memory size
int parallelization = 1; // currently not supported by Spring Security
int keyLength = 32;  // key length in bytes
int saltLength = 64;  // salt length in bytes

SCryptPasswordEncoder sCryptPasswordEncoder = new SCryptPasswordEncoder(
  cpuCost, 
  memoryCost,
  parallelization,
  keyLength,
  saltLength);
String encodedPassword = sCryptPasswordEncoder.encode(plainPassword);
```

The `scrypt` algorithm can not only configure the CPU cost but also memory cost. It makes the attack very expensive.
In this encoder the memory costs and CPU cost depends on each other and can not be tuned separately.
For example with the parameter from the code above, the password encoding will require 16MB memory.  

The output looks like this:
```
$e0801$jRlFuIUd6eAZcuM1wKrzswD8TeKPed9wuWf3lwsWkStxHs0DvdpOZQB32cQJnf0lq/dxL+QsbDpSyyc9Pnet1A==$P3imAo3G8k27RccgP5iR/uoP8FgWGSS920YnHj+CRVA=
```
This encoder puts the parameter for work factor and salt in the result string, so there is no additional information to save.

### `Argon2PasswordEncoder`
```java
int saltLength = 16; // salt length in bytes
int hashLength = 32; // hash length in bytes
int parallelism = 1; // currently not supported by Spring Security
int memory = 4096;  // memory costs
int iterations = 3;

Argon2PasswordEncoder argon2PasswordEncoder = new Argon2PasswordEncoder(
  saltLength,
  hashLength,
  parallelism,
  memory,
  iterations);
String encodePassword = argon2PasswordEncoder.encode(plainPassword);
```
Argon2 is the winner of [Password Hashing Competition](https://password-hashing.net/) in 2015. This algorithm, too, allows us to tune CPU and memory
costs. Argon2 encoder saves all the parameters in the result string. If we want to use this password encoder,
we'll have to import the BouncyCastle crypto library. 

## Setting Up a Password Encoder in Spring Boot
To see how it works in a Spring Boot let's create an application with REST APIs and password based authentication
supported by Spring Security. The passwords are stored in the relational database. 

To keep it simple in this example
we send the user credentials with every HTTP request. It means the application must start authentication whenever the client wants to access the API.

### Configuring a Password Encoder
First, we create an API we want to protect with Spring Security:
```java
@RestController
class CarResources {

  @GetMapping("/cars")
  public Set<Car> cars() {
  return Set.of(
   new Car("vw", "black"),
   new Car("bmw", "white"));
  }
}
```

Our goal is to provide access to the resource `/cars` for authenticated users only, so, we create a configuration with Spring Security rules:
```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  @Override
  protected void configure(HttpSecurity httpSecurity) throws Exception {
  httpSecurity
   .csrf()
   .disable()
   .authorizeRequests()
   .antMatchers("/registration")
   .permitAll()
   .anyRequest()
   .authenticated()
   .and()
   .httpBasic();
  }
  // other methods omitted

}
```
This code creates rules that require the authentication for all endpoints except `/registration`
and enables HTTP basic authentication. 

Every time when an HTTP request is sent to the application
Spring Security now checks if the header contains `Authorization: Basic <credentials>`.

If the header is not set, the server responds with HTTP status 401 (Unauthorized). 

If Spring Security finds the header, it starts the authentication.

To authenticate, Spring Security needs user data with user names and
password hashes. That's why we have to implement the `UserDetailsService` interface. This interface loads user-specific data and
needs read-only access to user data:

```java
@Service
public class DatabaseUserDetailsService implements UserDetailsService {

  private final UserRepository userRepository;
  private final UserDetailsMapper userDetailsMapper;

  public DatabaseUserDetailsService(
      UserRepository userRepository, 
      UserDetailsMapper userDetailsMapper) {
    this.userRepository = userRepository;
    this.userDetailsMapper = userDetailsMapper;
  }

  @Override
  public UserDetails loadUserByUsername(String username) 
                         throws UsernameNotFoundException {
    UserCredentials userCredentials =
                    userRepository.findByUsername(username);
    return userDetailsMapper.toUserDetails(userCredentials);
  }
}
```
In the service we implement the method `loadUserByUsername()`, that loads user data from the database.

An implementation of the `AuthenticationProvider` interface will use the `UserDetailsService`  to perform the authentication logic.
 
There are many implementations of this interface, but we are interested in `DaoAuthenticationProvider`,
because we store the data in the database: 
```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  private final DatabaseUserDetailsService databaseUserDetailsService;
  
  public SecurityConfiguration(
              DatabaseUserDetailsService databaseUserDetailsService) {
    this.databaseUserDetailsService = databaseUserDetailsService;
  }
  
  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth) 
                throws Exception {
    auth.authenticationProvider(daoAuthenticationProvider());
  }
  
  public AuthenticationProvider daoAuthenticationProvider() {
    DaoAuthenticationProvider provider = 
      new DaoAuthenticationProvider();
    provider.setPasswordEncoder(passwordEncoder());
    provider.setUserDetailsService(this.databaseUserDetailsService);
    return provider;
  }
  
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }
  
  // other methods omitted

}
```
We created a `DaoAuthenticationProvider` and passed in a `BCryptPasswordEncoder`.
That's all we need to do to enable password encoding and password matching.

Now we have to make one step more to complete the configuration. We 
set the `DatabaseUserDetailsService` service to the `DaoAuthenticationProvider`. After that, `DaoAuthenticationProvider` can 
get the user data to execute the authentication. Spring Security takes care of the rest. 

If a client sends a 
HTTP request with the basic authentication header, Spring Security will read this header, load data for the user, and matches the password using `BCryptPasswordEncoder`. If the password matches, the request will be passed
through, if not, the server will respond with HTTP status 401.

### Implementing User Registration 
To add a user to the system, let's implement the API for registration.
```java
@RestController
class RegistrationResource {

  private final UserRepository userRepository;
  private final PasswordEncoder passwordEncoder;

  public UserResources(UserRepository userRepository,
                       PasswordEncoder passwordEncoder) {
    this.userRepository = userRepository;
    this.passwordEncoder = passwordEncoder;
  }

  @PostMapping("/registration")
  @ResponseStatus(code = HttpStatus.CREATED)
  public void register(@RequestBody UserCredentialsDto userCredentialsDto) {
    UserCredentials user = UserCredentials.builder()
      .enabled(true)
      .username(userCredentialsDto.getUsername())
      .password(passwordEncoder.encode(userCredentialsDto.getPassword()))
      .roles(Set.of("USER"))
      .build();
    userRepository.save(user);
  }
}
``` 
As we defined in Spring Security rules, the access to `/registration` API is open for everybody. We use the `PasswordEncoder` that is defined in
Spring Security configuration to encode the password. 

In this example, the passwords are encoded with the `bcrypt` algorithm because we set the `PasswordEncoder`
as the password encoder in the configuration.
The code just saves the new user to the database. After that, the user is ready to authenticate.

## Upgrading The Work Factor
There are cases where we should increase the work factor of the password encoding for an existing application that
uses `PasswordEncoder`.

Maybe the work factor set years ago is not strong enough anymore today. Or maybe
the work factor we use today will not be secure in a couple of years. In these cases, we *should* increase the work factor
of password encoding. 

Also, the application might get better hardware. In this case, we *can*
increase work factors without significantly increasing authentication time. **Spring Security supports the update of the 
work factor for many encoding algorithms**.

To achieve this, we have to do two things. First, we need to implement `UserDetailsPasswordService` interface:
```java
@Service
@Transactional
public class DatabaseUserDetailPasswordService 
                implements UserDetailsPasswordService {

  private final UserRepository userRepository;

  private final UserDetailsMapper userDetailsMapper;

  public DatabaseUserDetailPasswordService(
      UserRepository userRepository, 
      UserDetailsMapper userDetailsMapper) {
    this.userRepository = userRepository;
    this.userDetailsMapper = userDetailsMapper;
  }

  @Override
  public UserDetails updatePassword(UserDetails user, String newPassword) {
    UserCredentials userCredentials =
              userRepository.findByUsername(user.getUsername());
    userCredentials.setPassword(newPassword);
    return userDetailsMapper.toUserDetails(userCredentials);
  }
}
```
In the method `updatePassword()` we just set the new password to the user in the database.

Second, we make this interface known to `AuthenticationProvider`:
```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  private final DatabaseUserDetailPasswordService
                               databaseUserDetailPasswordService;
  
  public SecurityConfiguration(
      DatabaseUserDetailPasswordService databaseUserDetailPasswordService) {
      this.databaseUserDetailPasswordService =
                                       databaseUserDetailPasswordService;
  }


  public AuthenticationProvider daoAuthenticationProvider() {
    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
    provider.setPasswordEncoder(passwordEncoder());
    provider.setUserDetailsPasswordService(
                this.databaseUserDetailPasswordService);
    provider.setUserDetailsService(this.databaseUserDetailsService);
    return provider;
  }
  
  // other methods omitted
}
```
That's it. Now, whenever a user starts the authentication, Spring Security compares the work factor in the encoded password
of the user with the current work factor of `PasswordEncoder`. 

**If the current work factor is stronger, the authentication
provider will encode the password of the user with the current password encoder and update it using `DatabaseUserDetailPasswordService`
automatically.**

For example, if passwords are currently encoded with `BCryptPasswordEncoder` of strength 5, we can just add a password encoder
of strength 10

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(10);
  }
  // other methods omitted
}
```

After that, **with each login, passwords are migrated from strength 5 to 10 automatically**.


## Using Multiple Password Encodings in the Same Application
Some applications live very long. Long enough that the standards and best practices for password encoding change. 

Imagine we support an application with thousands of users and this application uses a normal SHA-1 hashing for password encoding.
It means all passwords are stored in the database as SHA-1 hashes. 

Now, we want to raise security use `scrypt` instead for all new users. 

To encode and match passwords using different algorithms in the same application, we can use
`DelegatingPasswordEncoder`. This encoder delegates the encoding to another encoder using prefixes:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  @Bean
  public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
  }
  
  // other methods omitted
}
```
The simplest way is to let `PasswordEncoderFactories` generate the `DelegatingPasswordEncoder` for us. This factory generates a `DelegatingPasswordEncoder` that supports all encoders of Spring Security for matching.

`DelegatingPasswordEncoder` has one default encoder. The `PasswordEncoderFactories` sets
`BCryptPasswordEncoder` as the default encoder. Now, when user data is saved during registration,
the password encoder will encode the password and add a prefix at the beginning
of the result string. The encoded password looks like this:
```
{bcrypt}$2a$10$4V9kA793Pi2xf94dYFgKWuw8ukyETxWb7tZ4/mfco9sWkwvBQndxW
```

When the user with this password wants to authenticate, `DelegatingPasswordEncoder` can recognize the prefix und choose
the suitable encoder for matching. 

In the example with the old SHA-1 passwords, we have to run a SQL-script that prefixes all password hashes with `{SHA-1}`. From this moment, `DelegatingPasswordEncoder` can match the `SHA-1` password when the user wants to authenticate.

But let's say we don't want to use `BCryptPasswordEncoder` as the new default encoder, but `SCryptPasswordEncoder` instead.
We can set the default password encoder after creating `DelegatingPasswordEncoder`:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  @Bean
  public PasswordEncoder passwordEncoder() {
    DelegatingPasswordEncoder delegatingPasswordEncoder = 
        (DelegatingPasswordEncoder) PasswordEncoderFactories
                                  .createDelegatingPasswordEncoder();
    delegatingPasswordEncoder
      .setDefaultPasswordEncoderForMatches(new SCryptPasswordEncoder());
    return delegatingPasswordEncoder;
  }
  
  // other methods omitted
}
```

We can also take full control of which encoders should be supported if we create a `DelegatingPasswordEncoder` on our own:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  @Bean
  public PasswordEncoder passwordEncoder() {
    String encodingId = "scrypt";
    Map<String, PasswordEncoder> encoders = new HashMap<>();
    encoders.put(encodingId, new SCryptPasswordEncoder());
    encoders.put("SHA-1", new MessageDigestPasswordEncoder("SHA-1"));
    return new DelegatingPasswordEncoder(encodingId, encoders);
  }
  
  // other methods omitted
}
```
This code creates a password encoder that supports `SHA-1` and `scrypt` for matching and uses `scrypt` for encoding new passwords. Now we have users in the database with both password encodings `SHA-1` and `scrypt` and the application supports both.


## Migrating Password Encoding
If the passwords in the database are encoded by an old, easily attackable, algorithm, then we might want to
migrate the passwords to another encoding. To migrate a password to another encoding we have to encode the plain text
password. 

Of course, we don't have the plain password in the database and we can't compute it without huge effort. Also, we don't want to force the users to migrate their passwords. But we can implement a
slow gradual migration. 

Every time when the user authenticates we encode the plain password that the user sends
to the server and override the old one in the database. This approach is transparent to the users.

First, we have to set the `eraseCredentials` property to `false` in security configuration, because otherwise Spring Security removes the credentials from the memory as soon as possible.  

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  
  @Autowired
  public void configureGlobal(AuthenticationManagerBuilder auth)
                throws Exception {
    auth.authenticationProvider(daoAuthenticationProvider())
      .eraseCredentials(false);
  }
  // other methods omitted
}
```

Now we can implement an `ApplicationListener` for the `AuthenticationSuccessEvent`:
```java
@Component
class PasswordMigration {

  @Bean
  public ApplicationListener<AuthenticationSuccessEvent> 
                                      authenticationSuccessListener(
      PasswordEncoder encoder, 
      UserDetailsPasswordService userDetailsPasswordService) {
    return (AuthenticationSuccessEvent event) -> {
      Authentication authentication = event.getAuthentication();
      User user = (User) authentication.getPrincipal();
      String encodedPassword = user.getPassword();
      if (encodedPassword.startsWith("{SHA-1}")) {
        CharSequence clearTextPassword = (CharSequence) authentication
                                                        .getCredentials();
        String newPassword = encoder.encode(clearTextPassword);
        userDetailsPasswordService.updatePassword(user, newPassword);
      }
      ((UsernamePasswordAuthenticationToken) authentication)
                                                      .eraseCredentials();
    };
  }
}
```

This method is called every time when the authentication was successful. For the password update we use the 
`UserDetailsPasswordService` we implemented before. Note that at the end of the code we erase the credentials
of the user from memory.

## Calculating the Optimal Work Factor
How to choose the suitable work factor for the password encoder? Spring Security recommends tuning the
password encoder to take about 1 second to verify the password. But this time depends on the hardware, on which the application runs.

If the same application runs on different hardware for different customers, we can't set the best work factor at compile time.

But we can calculate a good work factor when starting the application:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder(
                bcCryptWorkFactorService.calculateStrength());
  }
  // other methods omitted
}
```  

The method `calculateStrength()` returns the work factor that is needed to encode the password so that it takes about 1
second. The method is executed by starting the application on the current hardware. If the application starts for different customers,
the best work factor will be found automatically. Note that this method can take several seconds. It means the start of the application
will be slower than usual. 

# Conclusion
Spring Security supports many password encoders, for both old and modern algorithms. Also, Spring Security
provides methods to work with multiple password encoding in one application. If we need, we can
change the work factor of password encodings or migrate from one encoding to another without affecting users.

You can find the example code [on GitHub](https://github.com/thombergs/code-examples/tree/master/spring-boot/password-encoding/).
 


  



 
 

